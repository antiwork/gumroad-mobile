import * as fs from "fs";
import * as path from "path";

const basicSvgDir = path.join(__dirname, "../node_modules/@boxicons/core/svg/basic");
const filledSvgDir = path.join(__dirname, "../node_modules/@boxicons/core/svg/filled");
const brandsSvgDir = path.join(__dirname, "../node_modules/@boxicons/core/svg/brands");
const outputDir = path.join(__dirname, "../components/icons");

if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Parse XML attributes from a string like `x="10" y="20"`
const parseAttrs = (attrString: string): Record<string, string> => {
  const attrs: Record<string, string> = {};
  const regex = /(\w+)="([^"]*)"/g;
  let match;
  while ((match = regex.exec(attrString)) !== null) {
    attrs[match[1]] = match[2];
  }
  return attrs;
};

const shapeToPath = {
  path: (attrs: Record<string, string>) => attrs.d || "",

  rect: (attrs: Record<string, string>) => {
    const x = parseFloat(attrs.x || "0");
    const y = parseFloat(attrs.y || "0");
    const w = parseFloat(attrs.width || "0");
    const h = parseFloat(attrs.height || "0");
    const rx = parseFloat(attrs.rx || "0");
    const ry = parseFloat(attrs.ry || attrs.rx || "0");

    if (rx > 0 || ry > 0) {
      const r = Math.min(rx, ry, w / 2, h / 2);
      return `M${x + r},${y} L${x + w - r},${y} Q${x + w},${y} ${x + w},${y + r} L${x + w},${y + h - r} Q${x + w},${y + h} ${x + w - r},${y + h} L${x + r},${y + h} Q${x},${y + h} ${x},${y + h - r} L${x},${y + r} Q${x},${y} ${x + r},${y} Z`;
    }
    return `M${x},${y} L${x + w},${y} L${x + w},${y + h} L${x},${y + h} Z`;
  },

  circle: (attrs: Record<string, string>) => {
    const cx = parseFloat(attrs.cx || "0");
    const cy = parseFloat(attrs.cy || "0");
    const r = parseFloat(attrs.r || "0");
    return `M${cx - r},${cy} A${r},${r} 0 1,0 ${cx + r},${cy} A${r},${r} 0 1,0 ${cx - r},${cy} Z`;
  },

  ellipse: (attrs: Record<string, string>) => {
    const cx = parseFloat(attrs.cx || "0");
    const cy = parseFloat(attrs.cy || "0");
    const rx = parseFloat(attrs.rx || "0");
    const ry = parseFloat(attrs.ry || "0");
    return `M${cx - rx},${cy} A${rx},${ry} 0 1,0 ${cx + rx},${cy} A${rx},${ry} 0 1,0 ${cx - rx},${cy} Z`;
  },

  line: (attrs: Record<string, string>) => {
    const x1 = parseFloat(attrs.x1 || "0");
    const y1 = parseFloat(attrs.y1 || "0");
    const x2 = parseFloat(attrs.x2 || "0");
    const y2 = parseFloat(attrs.y2 || "0");
    return `M${x1},${y1} L${x2},${y2}`;
  },

  polygon: (attrs: Record<string, string>) => {
    const points = attrs.points || "";
    const coords = points.trim().split(/\s+|,/).map(parseFloat);
    if (coords.length < 4) return "";
    let d = `M${coords[0]},${coords[1]}`;
    for (let i = 2; i < coords.length; i += 2) {
      d += ` L${coords[i]},${coords[i + 1]}`;
    }
    return d + " Z";
  },

  polyline: (attrs: Record<string, string>) => {
    const points = attrs.points || "";
    const coords = points.trim().split(/\s+|,/).map(parseFloat);
    if (coords.length < 4) return "";
    let d = `M${coords[0]},${coords[1]}`;
    for (let i = 2; i < coords.length; i += 2) {
      d += ` L${coords[i]},${coords[i + 1]}`;
    }
    return d;
  },
};

type SvgShape = keyof typeof shapeToPath;

const extractPathsFromSvg = (svgContent: string): string[] => {
  const paths: string[] = [];
  const shapes = Object.keys(shapeToPath).join("|");
  const regex = new RegExp(`<(${shapes})([^>]*?)(?:\\s*\\/?>|>(.*?)<\\/\\1>)`, "gi");

  let match;
  while ((match = regex.exec(svgContent)) !== null) {
    const shape = match[1].toLowerCase() as SvgShape;
    const attrs = parseAttrs(match[2]);
    const d = shapeToPath[shape]?.(attrs);
    if (d) paths.push(d);
  }

  return paths;
};

const getSvgFiles = (dir: string): string[] => fs.readdirSync(dir).filter((f) => f.endsWith(".svg"));

const processSvgDirectory = (dir: string, prefix: string): Record<string, string | string[]> => {
  const icons: Record<string, string | string[]> = {};

  for (const file of getSvgFiles(dir)) {
    const filePath = path.join(dir, file);
    const svgContent = fs.readFileSync(filePath, "utf-8");
    const paths = extractPathsFromSvg(svgContent);

    if (paths.length === 0) continue;

    let iconName = file.replace(/\.svg$/, "");
    if (iconName.startsWith(prefix)) {
      iconName = iconName.slice(prefix.length);
    }

    icons[iconName] = paths.length === 1 ? paths[0] : paths;
  }

  return icons;
};

const lineIcons = processSvgDirectory(basicSvgDir, "bx-");
const solidIcons = processSvgDirectory(filledSvgDir, "bx-");
const logoIcons = processSvgDirectory(brandsSvgDir, "bx-");

const output = `// Auto-generated by scripts/generate-boxicons.ts
// Do not edit manually

export const lineIconPaths = ${JSON.stringify(lineIcons, null, 2)} as const;

export const solidIconPaths = ${JSON.stringify(solidIcons, null, 2)} as const;

export const logoIconPaths = ${JSON.stringify(logoIcons, null, 2)} as const;

export type LineIconName = ${JSON.stringify(Object.keys(lineIcons).sort())}[number];
export type SolidIconName = ${JSON.stringify(Object.keys(solidIcons).sort())}[number];
export type LogoIconName = ${JSON.stringify(Object.keys(logoIcons).sort())}[number];
`;

fs.writeFileSync(path.join(outputDir, "icon-paths.ts"), output);

// eslint-disable-next-line no-console
console.log(
  `Generated ${Object.keys(lineIcons).length} line, ${Object.keys(solidIcons).length} solid, ${Object.keys(logoIcons).length} logo SVG icons to ${outputDir}`,
);
